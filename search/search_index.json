{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Blocky Blocky is a DNS proxy and ad-blocker for the local network written in Go with following features: Features Blocking - Blocking of DNS queries with external lists (Ad-block, malware) and whitelisting Definition of black and white lists per client group (Kids, Smart home devices, etc.) Periodical reload of external black and white lists Regex support Blocking of request domain, response CNAME (deep CNAME inspection) and response IP addresses (against IP lists) Advanced DNS configuration - not just an ad-blocker Custom DNS resolution for certain domain names Conditional forwarding to external DNS server Upstream resolvers can be defined per client group Performance - Improves speed and performance in your network Customizable caching of DNS answers for queries -> improves DNS resolution speed and reduces amount of external DNS queries Prefetching and caching of often used queries Using multiple external resolver simultaneously Low memory footprint Various Protocols - Supports modern DNS protocols DNS over UDP and TCP DNS over HTTPS (aka DoH ) DNS over TLS (aka DoT ) Security and Privacy - Secure communication Supports modern DNS extensions: DNSSEC , eDNS , ... Free configurable blocking lists - no hidden filtering etc. Provides DoH Endpoint Uses random upstream resolvers from the configuration - increases your privacy through the distribution of your DNS traffic over multiple provider Open source development Blocky does NOT collect any user data, telemetry, statistics etc. Integration - various integration Prometheus metrics Prepared Grafana dashboards (Prometheus and database) Logging of DNS queries per day / per client in CSV format or MySQL/MariaDB/PostgreSQL database - easy to analyze Various REST API endpoints CLI tool Simple configuration - single configuration file in YAML format Simple to maintain Simple to backup Simple installation/configuration - blocky was designed for simple installation Stateless (no database, no temporary files) Docker image with Multi-arch support Single binary Supports x86-64 and ARM architectures -> runs fine on Raspberry PI Community supported Helm chart for k8s deployment Contribution Issues, feature suggestions and pull requests are welcome! Blocky lives on GitHub .","title":"Welcome"},{"location":"#blocky","text":"Blocky is a DNS proxy and ad-blocker for the local network written in Go with following features:","title":"Blocky"},{"location":"#features","text":"Blocking - Blocking of DNS queries with external lists (Ad-block, malware) and whitelisting Definition of black and white lists per client group (Kids, Smart home devices, etc.) Periodical reload of external black and white lists Regex support Blocking of request domain, response CNAME (deep CNAME inspection) and response IP addresses (against IP lists) Advanced DNS configuration - not just an ad-blocker Custom DNS resolution for certain domain names Conditional forwarding to external DNS server Upstream resolvers can be defined per client group Performance - Improves speed and performance in your network Customizable caching of DNS answers for queries -> improves DNS resolution speed and reduces amount of external DNS queries Prefetching and caching of often used queries Using multiple external resolver simultaneously Low memory footprint Various Protocols - Supports modern DNS protocols DNS over UDP and TCP DNS over HTTPS (aka DoH ) DNS over TLS (aka DoT ) Security and Privacy - Secure communication Supports modern DNS extensions: DNSSEC , eDNS , ... Free configurable blocking lists - no hidden filtering etc. Provides DoH Endpoint Uses random upstream resolvers from the configuration - increases your privacy through the distribution of your DNS traffic over multiple provider Open source development Blocky does NOT collect any user data, telemetry, statistics etc. Integration - various integration Prometheus metrics Prepared Grafana dashboards (Prometheus and database) Logging of DNS queries per day / per client in CSV format or MySQL/MariaDB/PostgreSQL database - easy to analyze Various REST API endpoints CLI tool Simple configuration - single configuration file in YAML format Simple to maintain Simple to backup Simple installation/configuration - blocky was designed for simple installation Stateless (no database, no temporary files) Docker image with Multi-arch support Single binary Supports x86-64 and ARM architectures -> runs fine on Raspberry PI Community supported Helm chart for k8s deployment","title":"Features"},{"location":"#contribution","text":"Issues, feature suggestions and pull requests are welcome! Blocky lives on GitHub .","title":"Contribution"},{"location":"additional_information/","text":"Additional information Print current configuration To print runtime configuration / statistics, you can send SIGUSR1 signal to running process. Summary Example output: INFO server: current configuration: INFO server: -> resolver: 'ClientNamesResolver' INFO server: singleNameOrder = \"[2 1]\" INFO server: externalResolver = \"upstream 'tcp+udp:192.168.178.1:53'\" INFO server: cache item count = 7 INFO server: -> resolver: 'QueryLoggingResolver' INFO server: logDir= \"/logs\" INFO server: perClient = false INFO server: logRetentionDays= 7 INFO server: -> resolver: 'MetricsResolver' INFO server: metrics: INFO server: Enable = true INFO server: Path = /metrics INFO server: -> resolver: 'ConditionalUpstreamResolver' INFO server: fritz.box = \"parallel upstreams 'upstream 'tcp+udp:192.168.178.1:53''\" INFO server: -> resolver: 'CustomDNSResolver' INFO server: runtime information: ... INFO server: MEM Alloc = 9 MB INFO server: MEM HeapAlloc = 9 MB INFO server: MEM Sys = 88 MB INFO server: MEM NumGC = 1533 INFO server: RUN NumCPU = 4 INFO server: RUN NumGoroutine = 18 Hint To send a signal to a process you can use kill -s USR1 <PID> or docker kill -s SIGUSR1 blocky for docker setup Debug / Profiling If http listener is enabled, pprof endpoint ( /debug/pprof ) is enabled automatically. List sources Some links/ideas for lists: Blacklists https://github.com/StevenBlack/hosts https://github.com/nickspaargaren/no-google https://energized.pro/ https://github.com/Perflyst/PiHoleBlocklist https://github.com/kboghdady/youTube_ads_4_pi-hole https://github.com/chadmayfield/my-pihole-blocklists Warning Use only blacklists from the sources you trust! Whitelists https://github.com/anudeepND/whitelist List of public DNS servers Warning DNS server provider has access to all your DNS queries (all visited domain names). Some DNS providers can use (tracking, analyzing, profiling etc.). It is recommended to use different DNS upstream servers in blocky to distribute your DNS queries over multiple providers. Please read the description before using the DNS server as upstream. Some of them provide already an ad-blocker, some filters other content. If you use external DNS server with included ad-blocker, you can't choose which domains should be blocked, and you can't use whitelisting. This is only a small excerpt of all free available DNS servers and should only be understood as an idee. Info I will NOT rate the DNS providers in the list. This list is sorted alphabetically. AdGuard CloudFlare Comodo DigitalCourage DigitaleGesellschaft Dismail dnsforge Google OpenDNS Quad9 UncensoredDNS","title":"Additional information"},{"location":"additional_information/#additional-information","text":"","title":"Additional information"},{"location":"additional_information/#print-current-configuration","text":"To print runtime configuration / statistics, you can send SIGUSR1 signal to running process. Summary Example output: INFO server: current configuration: INFO server: -> resolver: 'ClientNamesResolver' INFO server: singleNameOrder = \"[2 1]\" INFO server: externalResolver = \"upstream 'tcp+udp:192.168.178.1:53'\" INFO server: cache item count = 7 INFO server: -> resolver: 'QueryLoggingResolver' INFO server: logDir= \"/logs\" INFO server: perClient = false INFO server: logRetentionDays= 7 INFO server: -> resolver: 'MetricsResolver' INFO server: metrics: INFO server: Enable = true INFO server: Path = /metrics INFO server: -> resolver: 'ConditionalUpstreamResolver' INFO server: fritz.box = \"parallel upstreams 'upstream 'tcp+udp:192.168.178.1:53''\" INFO server: -> resolver: 'CustomDNSResolver' INFO server: runtime information: ... INFO server: MEM Alloc = 9 MB INFO server: MEM HeapAlloc = 9 MB INFO server: MEM Sys = 88 MB INFO server: MEM NumGC = 1533 INFO server: RUN NumCPU = 4 INFO server: RUN NumGoroutine = 18 Hint To send a signal to a process you can use kill -s USR1 <PID> or docker kill -s SIGUSR1 blocky for docker setup","title":"Print current configuration"},{"location":"additional_information/#debug-profiling","text":"If http listener is enabled, pprof endpoint ( /debug/pprof ) is enabled automatically.","title":"Debug / Profiling"},{"location":"additional_information/#list-sources","text":"Some links/ideas for lists:","title":"List sources"},{"location":"additional_information/#blacklists","text":"https://github.com/StevenBlack/hosts https://github.com/nickspaargaren/no-google https://energized.pro/ https://github.com/Perflyst/PiHoleBlocklist https://github.com/kboghdady/youTube_ads_4_pi-hole https://github.com/chadmayfield/my-pihole-blocklists Warning Use only blacklists from the sources you trust!","title":"Blacklists"},{"location":"additional_information/#whitelists","text":"https://github.com/anudeepND/whitelist","title":"Whitelists"},{"location":"additional_information/#list-of-public-dns-servers","text":"Warning DNS server provider has access to all your DNS queries (all visited domain names). Some DNS providers can use (tracking, analyzing, profiling etc.). It is recommended to use different DNS upstream servers in blocky to distribute your DNS queries over multiple providers. Please read the description before using the DNS server as upstream. Some of them provide already an ad-blocker, some filters other content. If you use external DNS server with included ad-blocker, you can't choose which domains should be blocked, and you can't use whitelisting. This is only a small excerpt of all free available DNS servers and should only be understood as an idee. Info I will NOT rate the DNS providers in the list. This list is sorted alphabetically. AdGuard CloudFlare Comodo DigitalCourage DigitaleGesellschaft Dismail dnsforge Google OpenDNS Quad9 UncensoredDNS","title":"List of public DNS servers"},{"location":"configuration/","text":"Configuration This chapter describes all configuration options in config.yaml . You can download a reference file with all configuration properties as JSON . reference configuration file upstream : # these external DNS resolvers will be used. Blocky picks 2 random resolvers from the list for each query # format for resolver: [net:]host:[port][/path]. net could be empty (default, shortcut for tcp+udp), tcp+udp, tcp, udp, tcp-tls or https (DoH). If port is empty, default port will be used (53 for udp and tcp, 853 for tcp-tls, 443 for https (Doh)) # this configuration is mandatory, please define at least one external DNS resolver default : # example for tcp+udp IPv4 server (https://digitalcourage.de/) - 5.9.164.112 # Cloudflare - 1.1.1.1 # example for DNS-over-TLS server (DoT) - tcp-tls:fdns1.dismail.de:853 # example for DNS-over-HTTPS (DoH) - https://dns.digitale-gesellschaft.ch/dns-query # optional: use client name (with wildcard support: * - sequence of any characters, [0-9] - range) # or single ip address / client subnet as CIDR notation laptop* : - 123.123.123.123 # optional: timeout to query the upstream resolver. Default: 2s upstreamTimeout : 2s # optional: If true, blocky will fail to start unless at least one upstream server per group is reachable. Default: false startVerifyUpstream : true # optional: Determines how blocky will create outgoing connections. This impacts both upstreams, and lists. # accepted: dual, v4, v6 # default: dual connectIPVersion : dual # optional: custom IP address(es) for domain name (with all sub-domains). Multiple addresses must be separated by a comma # example: query \"printer.lan\" or \"my.printer.lan\" will return 192.168.178.3 customDNS : customTTL : 1h # optional: if true (default), return empty result for unmapped query types (for example TXT, MX or AAAA if only IPv4 address is defined). # if false, queries with unmapped types will be forwarded to the upstream resolver filterUnmappedTypes : true # optional: replace domain in the query with other domain before resolver lookup in the mapping rewrite : example.com : printer.lan mapping : printer.lan : 192.168.178.3,2001:0db8:85a3:08d3:1319:8a2e:0370:7344 # optional: definition, which DNS resolver(s) should be used for queries to the domain (with all sub-domains). Multiple resolvers must be separated by a comma # Example: Query client.fritz.box will ask DNS server 192.168.178.1. This is necessary for local network, to resolve clients by host name conditional : # optional: if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver # Example: The query \"blog.example.com\" will be rewritten to \"blog.fritz.box\" and also redirected to the resolver at 192.168.178.1. If not found and if `fallbackUpstream` was set to `true`, the original query \"blog.example.com\" will be sent upstream. # Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain. fallbackUpstream : false # optional: replace domain in the query with other domain before resolver lookup in the mapping rewrite : example.com : fritz.box mapping : fritz.box : 192.168.178.1 lan.net : 192.168.178.1,192.168.178.2 # optional: use black and white lists to block queries (for example ads, trackers, adult pages etc.) blocking : # definition of blacklist groups. Can be external link (http/https) or local file blackLists : ads : - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts - http://sysctl.org/cameleon/hosts - https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt - | # inline definition with YAML literal block scalar style # hosts format someadsdomain.com special : - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts # definition of whitelist groups. Attention: if the same group has black and whitelists, whitelists will be used to disable particular blacklist entries. If a group has only whitelist entries -> this means only domains from this list are allowed, all other domains will be blocked whiteLists : ads : - whitelist.txt - | # inline definition with YAML literal block scalar style # hosts format whitelistdomain.com # this is a regex /^banners?[_.-]/ # definition: which groups should be applied for which client clientGroupsBlock : # default will be used, if no special definition for a client name exists default : - ads - special # use client name (with wildcard support: * - sequence of any characters, [0-9] - range) # or single ip address / client subnet as CIDR notation laptop* : - ads 192.168.178.1/24 : - special # which response will be sent, if query is blocked: # zeroIp: 0.0.0.0 will be returned (default) # nxDomain: return NXDOMAIN as return code # comma separated list of destination IP addresses (for example: 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344). Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page. blockType : zeroIp # optional: TTL for answers to blocked domains # default: 6h blockTTL : 1m # optional: automatically list refresh period (in duration format). Default: 4h. # Negative value -> deactivate automatically refresh. # 0 value -> use default refreshPeriod : 4h # optional: timeout for list download (each url). Default: 60s. Use large values for big lists or slow internet connections downloadTimeout : 4m # optional: Download attempt timeout. Default: 60s downloadAttempts : 5 # optional: Time between the download attempts. Default: 1s downloadCooldown : 10s # optional: if failOnError, application startup will fail if at least one list can't be downloaded / opened. Default: blocking startStrategy : failOnError # optional: configuration for caching of DNS responses caching : # duration how long a response must be cached (min value). # If <=0, use response's TTL, if >0 use this value, if TTL is smaller # Default: 0 minTime : 5m # duration how long a response must be cached (max value). # If <0, do not cache responses # If 0, use TTL # If > 0, use this value, if TTL is greater # Default: 0 maxTime : 30m # Max number of cache entries (responses) to be kept in cache (soft limit). Useful on systems with limited amount of RAM. # Default (0): unlimited maxItemsCount : 0 # if true, will preload DNS results for often used queries (default: names queried more than 5 times in a 2-hour time window) # this improves the response time for often used queries, but significantly increases external traffic # default: false prefetching : true # prefetch track time window (in duration format) # default: 120 prefetchExpires : 2h # name queries threshold for prefetch # default: 5 prefetchThreshold : 5 # Max number of domains to be kept in cache for prefetching (soft limit). Useful on systems with limited amount of RAM. # Default (0): unlimited prefetchMaxItemsCount : 0 # Time how long negative results (NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results. # Default: 30m cacheTimeNegative : 30m # optional: configuration of client name resolution clientLookup : # optional: this DNS resolver will be used to perform reverse DNS lookup (typically local router) upstream : 192.168.178.1 # optional: some routers return multiple names for client (host name and user defined name). Define which single name should be used. # Example: take second name if present, if not take first name singleNameOrder : - 2 - 1 # optional: custom mapping of client name to IP addresses. Useful if reverse DNS does not work properly or just to have custom client names. clients : laptop : - 192.168.178.29 # optional: configuration for prometheus metrics endpoint prometheus : # enabled if true enable : true # url path, optional (default '/metrics') path : /metrics # optional: write query information (question, answer, client, duration etc.) to daily csv file queryLog : # optional one of: mysql, postgresql, csv, csv-client. If empty, log to console type : mysql # directory (should be mounted as volume in docker) for csv, db connection string for mysql/postgresql target : db_user:db_password@tcp(db_host_or_ip:3306)/db_name?charset=utf8mb4&parseTime=True&loc=Local #postgresql target: postgres://user:password@db_host_or_ip:5432/db_name # if > 0, deletes log files which are older than ... days logRetentionDays : 7 # optional: Max attempts to create specific query log writer, default: 3 creationAttempts : 1 # optional: Time between the creation attempts, default: 2s creationCooldown : 2s # optional: Blocky can synchronize its cache and blocking state between multiple instances through redis. redis : # Server address and port address : redis:6379 # Password if necessary password : passwd # Database, default: 0 database : 2 # Connection is required for blocky to start. Default: false required : true # Max connection attempts, default: 3 connectionAttempts : 10 # Time between the connection attempts, default: 1s connectionCooldown : 3s # optional: DNS listener port(s) and bind ip address(es), default 53 (UDP and TCP). Example: 53, :53, \"127.0.0.1:5353,[::1]:5353\" port : 53 # optional: Port(s) and bind ip address(es) for DoT (DNS-over-TLS) listener. Example: 853, 127.0.0.1:853 #tlsPort: 853 # optional: HTTPS listener port(s) and bind ip address(es), default empty = no http listener. If > 0, will be used for prometheus metrics, pprof, REST API, DoH... Example: 443, :443, 127.0.0.1:443 httpPort : 4000 #httpsPort: 443 # optional: Mininal TLS version that the DoH and DoT server will use minTlsServeVersion : 1.3 # if https port > 0: path to cert and key file for SSL encryption. if not set, self-signed certificate will be generated #certFile: server.crt #keyFile: server.key # optional: use this DNS server to resolve blacklist urls and upstream DNS servers. Useful if no DNS resolver is configured and blocky needs to resolve a host name. Format net:IP:port, net must be udp or tcp bootstrapDns : tcp+udp:1.1.1.1 filtering : # optional: drop all queries with following query types. Default: empty queryTypes : - AAAA # optional: if path defined, use this file for query resolution (A, AAAA and rDNS). Default: empty hostsFile : # optional: Path to hosts file (e.g. /etc/hosts on Linux) filePath : /etc/hosts # optional: TTL, default: 1h hostsTTL : 60m # optional: Time between hosts file refresh, default: 1h refreshPeriod : 30m # optional: Whether loopback hosts addresses (127.0.0.0/8 and ::1) should be filtered or not, default: false filterLoopback : true # optional: Log level (one from debug, info, warn, error). Default: info logLevel : info # optional: Log format (text or json). Default: text logFormat : text # optional: log timestamps. Default: true logTimestamp : true # optional: obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. Default: false logPrivacy : false # optional: add EDE error codes to dns response ede : # enabled if true, Default: false enable : true Basic configuration Parameter Type Mandatory Default value Description port [IP]:port[,[IP]:port]* no 53 Port(s) and optional bind ip address(es) to serve DNS endpoint ( TCP and UDP ). If you wish to specify a specific IP, you can do so such as 192.168.0.1:53 . Example: 53 , :53 , 127.0.0.1:53,[::1]:53 tlsPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve DoT DNS endpoint ( DNS -over-TLS). If you wish to specify a specific IP, you can do so such as 192.168.0.1:853 . Example: 83 , :853 , 127.0.0.1:853,[::1]:853 httpPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve HTTP used for prometheus metrics, pprof, REST API , DoH ... If you wish to specify a specific IP, you can do so such as 192.168.0.1:4000 . Example: 4000 , :4000 , 127.0.0.1:4000,[::1]:4000 httpsPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve HTTPS used for prometheus metrics, pprof, REST API , DoH ... If you wish to specify a specific IP, you can do so such as 192.168.0.1:443 . Example: 443 , :443 , 127.0.0.1:443,[::1]:443 certFile path no Path to cert and key file for SSL encryption ( DoH and DoT ); if empty, self-signed certificate is generated keyFile path no Path to cert and key file for SSL encryption ( DoH and DoT ); if empty, self-signed certificate is generated logLevel enum (debug, info, warn, error) no info Log level logFormat enum (text, json) no text Log format (text or json). logTimestamp bool no true Log time stamps (true or false). logPrivacy bool no false Obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. dohUserAgent string no HTTP User Agent for DoH upstreams minTlsServeVersion string no 1.2 Minimum TLS version that the DoT and DoH server use to serve those encrypted DNS requests startVerifyUpstream bool no false If true, blocky will fail to start unless at least one upstream server per group is reachable. connectIPVersion bool no dual IP version to use for outgoing connections (dual, v4, v6) Example port : 53 httpPort : 4000 httpsPort : 443 logLevel : info Upstream configuration To resolve a DNS query, blocky needs external public or private DNS resolvers. Blocky supports DNS resolvers with following network protocols (net part of the resolver URL): tcp+udp ( UDP and TCP , dependent on query type) https (aka DoH ) tcp-tls (aka DoT ) Hint You can (and should!) configure multiple DNS resolvers. Blocky picks 2 random resolvers from the list for each query and returns the answer from the fastest one. This improves your network speed and increases your privacy - your DNS traffic will be distributed over multiple providers. Each resolver must be defined as a string in following format: [net:]host:[port][/path][#commonName] . Parameter Type Mandatory Default value net enum (tcp+udp, tcp-tls or https) no tcp+udp host IP or hostname yes port int (1 - 65535) no 53 for udp/tcp, 853 for tcp-tls and 443 for https commonName string no the host value The commonName parameter overrides the expected certificate common name value used for verification. Blocky needs at least the configuration of the default group. This group will be used as a fallback, if no client specific resolver configuration is available. You can use the client name (see Client name lookup ), client's IP address or a client subnet as CIDR notation. Tip You can use * as wildcard for the sequence of any character or [0-9] as number range Example upstream : default : - 5.9.164.112 - 1.1.1.1 - tcp-tls:fdns1.dismail.de:853 - https://dns.digitale-gesellschaft.ch/dns-query laptop* : - 123.123.123.123 10.43.8.67/28 : - 1.1.1.1 - 9.9.9.9 Use 123.123.123.123 as single upstream DNS resolver for client laptop-home, 1.1.1.1 and 9.9.9.9 for all clients in the sub-net 10.43.8.67/28 and 4 resolvers (default) for all others clients. Note Blocky needs at least one upstream DNS server See List of public DNS servers if you need some ideas, which public free DNS server you could use. Upstream lookup timeout Blocky will wait 2 seconds (default value) for the response from the external upstream DNS server. You can change this value by setting the upstreamTimeout configuration parameter (in duration format ). Example upstream : default : - 46.182.19.48 - 80.241.218.68 upstreamTimeout : 5s Bootstrap DNS configuration This DNS server is used to resolve upstream DoH and DoT servers that are specified as hostnames. Useful if no system DNS resolver is configured, and to encrypt the bootstrap queries. Parameter Type Mandatory Default value Description upstream Upstream (see below) no ips List of IPs yes, if upstream is DoT / DoH Only valid if upstream is DoH or DoT If you only need to specify upstream, you can use the short form: bootstrapDns: <upstream> . Note Works only on Linux/*nix OS due to golang limitations under Windows. Example bootstrapDns : upstream : tcp-tls:dns.example.com ips : - 123.123.123.123 Filtering Under certain circumstances, it may be useful to filter some types of DNS queries. You can define one or more DNS query types, all queries with these types will be dropped (empty answer will be returned). Example filtering : queryTypes : - AAAA This configuration will drop all 'AAAA' (IPv6) queries. FQDN only In domain environments, it may be usefull to only response to FQDN requests. If this option is enabled blocky respond immidiatly with NXDOMAIN if the request is not a valid FQDN. The request is therfore not further processed by other options like custom or conditional. Please be aware that by enabling it your hostname resolution will break unless every hostname is part of a domain. Example fqdnOnly : true Custom DNS You can define your own domain name to IP mappings. For example, you can use a user-friendly name for a network printer or define a domain name for your local device on order to use the HTTPS certificate. Multiple IP addresses for one domain must be separated by a comma. Parameter Type Mandatory Default value customTTL duration (no unit is minutes) no 1h rewrite string: string (domain: domain) no mapping string: string (hostname: address list) no filterUnmappedTypes boolean no true Example customDNS : customTTL : 1h filterUnmappedTypes : true rewrite : home : lan replace-me.com : with-this.com mapping : printer.lan : 192.168.178.3 otherdevice.lan : 192.168.178.15,2001:0db8:85a3:08d3:1319:8a2e:0370:7344 This configuration will also resolve any subdomain of the defined domain. For example a query \"printer.lan\" or \" my.printer.lan\" will return 192.168.178.3 as IP address. With the optional parameter rewrite you can replace domain part of the query with the defined part before the resolver lookup is performed. The query \"printer.home\" will be rewritten to \"printer.lan\" and return 192.168.178.3. With parameter filterUnmappedTypes = true (default), blocky will filter all queries with unmapped types, for example: AAAA for \"printer.lan\" or TXT for \"otherdevice.lan\". With filterUnmappedTypes = false a query AAAA \"printer.lan\" will be forwarded to the upstream DNS server. Conditional DNS resolution You can define, which DNS resolver(s) should be used for queries for the particular domain (with all subdomains). This is for example useful, if you want to reach devices in your local network by the name. Since only your router know which hostname belongs to which IP address, all DNS queries for the local network should be redirected to the router. The optional parameter rewrite behaves the same as with custom DNS . The optional parameter fallbackUpstream, if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver. Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain Example conditional : fallbackUpstream : false rewrite : example.com : fritz.box replace-me.com : with-this.com mapping : fritz.box : 192.168.178.1 lan.net : 192.170.1.2,192.170.1.3 # for reverse DNS lookups of local devices 178.168.192.in-addr.arpa : 192.168.178.1 # for all unqualified hostnames . : 168.168.0.1 Tip You can use . as wildcard for all non full qualified domains (domains without dot) In this example, a DNS query \"client.fritz.box\" will be redirected to the router's DNS server at 192.168.178.1 and client.lan.net to 192.170.1.2 and 192.170.1.3. The query \"client.example.com\" will be rewritten to \"client.fritz.box\" and also redirected to the resolver at 192.168.178.1. If not found and if fallbackUpstream was set to true , the original query \"blog.example.com\" will be sent upstream. All unqualified hostnames (e.g. \"test\") will be redirected to the DNS server at 168.168.0.1. One usecase for fallbackUpstream is when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain. Client name lookup Blocky can try to resolve a user-friendly client name from the IP address or server URL ( DoT and DoH ). This is useful for defining of blocking groups, since IP address can change dynamically. Resolving client name from URL/Host If DoT or DoH is enabled, you can use a subdomain prefixed with id- to provide a client name (wildcard ssl certificate recommended). Example: domain example.com DoT Host: id-bob.example.com -> request's client name is bob DoH URL: https://id-bob.example.com/dns-query -> request's client name is bob For DoH you can also pass the client name as url parameter: DoH URL: https://blocky.example.com/dns-query/alice -> request's client name is alice Resolving client name from IP address Blocky uses rDNS to retrieve client's name. To use this feature, you can configure a DNS server for client lookup ( typically your router). You can also define client names manually per IP address. Single name order Some routers return multiple names for the client (host name and user defined name). With parameter clientLookup.singleNameOrder you can specify, which of retrieved names should be used. Custom client name mapping You can also map a particular client name to one (or more) IP (ipv4/ipv6) addresses. Parameter clientLookup.clients contains a map of client name and multiple IP addresses. Example clientLookup : upstream : 192.168.178.1 singleNameOrder : - 2 - 1 clients : laptop : - 192.168.178.29 Use 192.168.178.1 for rDNS lookup. Take second name if present, if not take first name. IP address 192.168.178.29 is mapped to laptop as client name. Blocking and whitelisting Blocky can download and use external lists with domains or IP addresses to block DNS query (e.g. advertisement, malware, trackers, adult sites). You can group several list sources together and define the blocking behavior per client. External blacklists must be either in the well-known Hosts format or just a plain domain list (one domain per line). Blocky also supports regex as more powerful tool to define patterns to block. Blocky uses DNS sinkhole approach to block a DNS query. Domain name from the request, IP address from the response, and the CNAME record will be checked against configured blacklists. To avoid over-blocking, you can define or use already existing whitelists. Definition black and whitelists Each black or whitelist can be either a path to the local file, a URL to download or inline list definition of a domains in hosts format ( YAML literal block scalar style). All Urls must be grouped to a group name. Example blocking : blackLists : ads : - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts - | # inline definition with YAML literal block scalar style someadsdomain.com anotheradsdomain.com # this is a regex /^banners?[_.-]/ special : - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts whiteLists : ads : - whitelist.txt - | # inline definition with YAML literal block scalar style whitelistdomain.com In this example you can see 2 groups: ads with 2 lists and special with one list. One local whitelist was defined for the ads group. Warning If the same group has black and whitelists, whitelists will be used to disable particular blacklist entries. If a group has only whitelist entries -> this means only domains from this list are allowed, all other domains will be blocked Note Please define also client group mapping, otherwise you black and whitelist definition will have no effect Regex support You can use regex to define patterns to block. A regex entry must start and end with the slash character (/). Some Examples: /baddomain/ will block www.baddomain.com , baddomain.com , but also mybaddomain-sometext.com /^baddomain/ will block baddomain.com , but not www.baddomain.com /^apple\\.(de|com)$/ will only block apple.de and apple.com Client groups In this configuration section, you can define, which blocking group(s) should be used for which client in your network. Example: All clients should use the ads group, which blocks advertisement and kids devices should use the adult group, which blocky adult sites. Clients without a group assignment will use automatically the default group. You can use the client name (see Client name lookup ), client's IP address, client's full-qualified domain name or a client subnet as CIDR notation. If full-qualified domain name is used (for example \"myclient.ddns.org\"), blocky will try to resolve the IP address (A and AAAA records) of this domain. If client's IP address matches with the result, the defined group will be used. Example blocking : clientGroupsBlock : # default will be used, if no special definition for a client name exists default : - ads - special laptop* : - ads 192.168.178.1/24 : - special kid-laptop : - ads - adult All queries from network clients, whose device name starts with laptop , will be filtered against the ads group's lists. All devices from the subnet 192.168.178.1/24 against the special group and kid-laptop against ads and adult . All other clients: ads and special . Tip You can use * as wildcard for the sequence of any character or [0-9] as number range Block type You can configure, which response should be sent to the client, if a requested query is blocked (only for A and AAAA queries, NXDOMAIN for other types): blockType Example Description zeroIP zeroIP This is the default block type. Server returns 0.0.0.0 (or :: for IPv6) as result for A and AAAA queries nxDomain nxDomain return NXDOMAIN as return code custom IPs 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 comma separated list of destination IP addresses. Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page. Example blocking : blockType : nxDomain Block TTL TTL for answers to blocked domains can be set to customize the time (in duration format ) clients ask for those domains again. Default Block TTL is 6hours . This setting only makes sense when blockType is set to nxDomain or zeroIP , and will affect how much time it could take for a client to be able to see the real IP address for a domain after receiving the custom value. Example blocking : blockType : 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 blockTTL : 10s List refresh period To keep the list cache up-to-date, blocky will periodically download and reload all external lists. Default period is 4 hours . You can configure this by setting the blocking.refreshPeriod parameter to a value in duration format . Negative value will deactivate automatically refresh. Example blocking : refreshPeriod : 60m Refresh every hour. Download You can configure the list download attempts according to your internet connection: Parameter Type Mandatory Default value Description downloadTimeout duration format no 60s Download attempt timeout downloadAttempts int no 3 How many download attempts should be performed downloadCooldown duration format no 1s Time between the download attempts Example blocking : downloadTimeout : 4m downloadAttempts : 5 downloadCooldown : 10s Start strategy You can configure the blocking behavior during application start of blocky. If no starategy is selected blocking will be used. startStrategy Description blocking all blocking lists will be loaded before DNS resoulution starts failOnError like blocking but blocky shutsdown if an download fails fast DNS resolution starts immediately without blocking which will be enabled after list load is completed Example blocking : startStrategy : failOnError Concurrency Blocky downloads and processes links in a single group concurrently. With parameter processingConcurrency you can adjust how many links can be processed in the same time. Higher value can reduce the overall list refresh time, but more parallel download and processing jobs need more RAM. Please consider to reduce this value on systems with limited memory. Default value is 4. Example blocking : processingConcurrency : 10 Caching Each DNS response has a TTL (Time-to-live) value. This value defines, how long is the record valid in seconds. The values are maintained by domain owners, server administrators etc. Blocky caches the answers from all resolved queries in own cache in order to avoid repeated requests. This reduces the DNS traffic and increases the network speed, since blocky can serve the result immediately from the cache. With following parameters you can tune the caching behavior: Warning Wrong values can significantly increase external DNS traffic or memory consumption. Parameter Type Mandatory Default value Description caching.minTime duration format no 0 (use TTL ) How long a response must be cached (min value). If <=0, use response's TTL , if >0 use this value, if TTL is smaller caching.maxTime duration format no 0 (use TTL ) How long a response must be cached (max value). If <0, do not cache responses. If 0, use TTL . If > 0, use this value, if TTL is greater caching.maxItemsCount int no 0 (unlimited) Max number of cache entries (responses) to be kept in cache (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.prefetching bool no false if true, blocky will preload DNS results for often used queries (default: names queried more than 5 times in a 2 hour time window). Results in cache will be loaded again on their expire ( TTL ). This improves the response time for often used queries, but significantly increases external traffic. It is recommended to increase \"minTime\" to reduce the number of prefetch queries to external resolvers. caching.prefetchExpires duration format no 2h Prefetch track time window caching.prefetchThreshold int no 5 Name queries threshold for prefetch caching.prefetchMaxItemsCount int no 0 (unlimited) Max number of domains to be kept in cache for prefetching (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.cacheTimeNegative duration format no 30m Time how long negative results ( NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results. Example caching : minTime : 5m maxTime : 30m prefetching : true Redis Blocky can synchronize its cache and blocking state between multiple instances through redis. Synchronization is disabled if no address is configured. Parameter Type Mandatory Default value Description redis.address string no Server address and port redis.password string no Password if necessary redis.database int no 0 Database redis.required bool no false Connection is required for blocky to start redis.connectionAttempts int no 3 Max connection attempts redis.connectionCooldown duration format no 1s Time between the connection attempts Example redis : address : redis:6379 password : passwd database : 2 required : true connectionAttempts : 10 connectionCooldown : 3s Prometheus Blocky can expose various metrics for prometheus. To use the prometheus feature, the HTTP listener must be enabled ( see Basic Configuration ). Parameter Mandatory Default value Description prometheus.enable no false If true, enables prometheus metrics prometheus.path no /metrics URL path to the metrics endpoint Example prometheus : enable : true path : /metrics Query logging You can enable the logging of DNS queries (question, answer, client, duration etc.) to a daily CSV file (can be opened in Excel or OpenOffice Calc) or MySQL/MariaDB database. Warning Query file/database contains sensitive information. Please ensure to inform users, if you log their queries. Query log types You can select one of following query log types: mysql - log each query in the external MySQL/MariaDB database postgresql - log each query in the external PostgreSQL database csv - log into CSV file (one per day) csv-client - log into CSV file (one per day and per client) console - log into console output none - do not log any queries Configuration parameters: Parameter Type Mandatory Default value Description queryLog.type enum (mysql, postgresql, csv, csv-client, console, none (see above)) no Type of logging target. Console if empty queryLog.target string no directory for writing the logs (for csv) or database url (for mysql or postgresql) queryLog.logRetentionDays int no 0 if > 0, deletes log files/database entries which are older than ... days queryLog.creationAttempts int no 3 Max attempts to create specific query log writer queryLog.CreationCooldown duration format no 2 Time between the creation attempts Hint Please ensure, that the log directory is writable or database exists. If you use docker, please ensure, that the directory is properly mounted (e.g. volume) example for CSV format Example queryLog : type : csv target : /logs logRetentionDays : 7 example for Database Example queryLog : type : mysql target : db_user:db_password@tcp(db_host_or_ip:3306)/db_user?charset=utf8mb4&parseTime=True&loc=Local logRetentionDays : 7 Hosts file You can enable resolving of entries, located in local hosts file. Configuration parameters: Parameter Type Mandatory Default value Description hostsFile.filePath string no Path to hosts file (e.g. /etc/hosts on Linux) hostsFile.hostsTTL duration (no units is minutes) no 1h TTL hostsFile.refreshPeriod duration format no 1h Time between hosts file refresh hostsFile.filterLoopback bool no false Filter loopback addresses (127.0.0.0/8 and ::1) Example hostsFile : filePath : /etc/hosts hostsTTL : 60m refreshPeriod : 30m Deliver EDE codes as EDNS0 option DNS responses can be extended with EDE codes according to RFC8914 . Configuration parameters: Parameter Type Mandatory Default value Description ede.enable bool no false If true, DNS responses are deliverd with EDE codes Example ede : enable : true SSL certificate configuration ( DoH / TLS listener) See Wiki - Configuration of HTTPS for detailed information, how to create and configure SSL certificates. DoH url: https://host:port/dns-query","title":"Configuration"},{"location":"configuration/#configuration","text":"This chapter describes all configuration options in config.yaml . You can download a reference file with all configuration properties as JSON . reference configuration file upstream : # these external DNS resolvers will be used. Blocky picks 2 random resolvers from the list for each query # format for resolver: [net:]host:[port][/path]. net could be empty (default, shortcut for tcp+udp), tcp+udp, tcp, udp, tcp-tls or https (DoH). If port is empty, default port will be used (53 for udp and tcp, 853 for tcp-tls, 443 for https (Doh)) # this configuration is mandatory, please define at least one external DNS resolver default : # example for tcp+udp IPv4 server (https://digitalcourage.de/) - 5.9.164.112 # Cloudflare - 1.1.1.1 # example for DNS-over-TLS server (DoT) - tcp-tls:fdns1.dismail.de:853 # example for DNS-over-HTTPS (DoH) - https://dns.digitale-gesellschaft.ch/dns-query # optional: use client name (with wildcard support: * - sequence of any characters, [0-9] - range) # or single ip address / client subnet as CIDR notation laptop* : - 123.123.123.123 # optional: timeout to query the upstream resolver. Default: 2s upstreamTimeout : 2s # optional: If true, blocky will fail to start unless at least one upstream server per group is reachable. Default: false startVerifyUpstream : true # optional: Determines how blocky will create outgoing connections. This impacts both upstreams, and lists. # accepted: dual, v4, v6 # default: dual connectIPVersion : dual # optional: custom IP address(es) for domain name (with all sub-domains). Multiple addresses must be separated by a comma # example: query \"printer.lan\" or \"my.printer.lan\" will return 192.168.178.3 customDNS : customTTL : 1h # optional: if true (default), return empty result for unmapped query types (for example TXT, MX or AAAA if only IPv4 address is defined). # if false, queries with unmapped types will be forwarded to the upstream resolver filterUnmappedTypes : true # optional: replace domain in the query with other domain before resolver lookup in the mapping rewrite : example.com : printer.lan mapping : printer.lan : 192.168.178.3,2001:0db8:85a3:08d3:1319:8a2e:0370:7344 # optional: definition, which DNS resolver(s) should be used for queries to the domain (with all sub-domains). Multiple resolvers must be separated by a comma # Example: Query client.fritz.box will ask DNS server 192.168.178.1. This is necessary for local network, to resolve clients by host name conditional : # optional: if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver # Example: The query \"blog.example.com\" will be rewritten to \"blog.fritz.box\" and also redirected to the resolver at 192.168.178.1. If not found and if `fallbackUpstream` was set to `true`, the original query \"blog.example.com\" will be sent upstream. # Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain. fallbackUpstream : false # optional: replace domain in the query with other domain before resolver lookup in the mapping rewrite : example.com : fritz.box mapping : fritz.box : 192.168.178.1 lan.net : 192.168.178.1,192.168.178.2 # optional: use black and white lists to block queries (for example ads, trackers, adult pages etc.) blocking : # definition of blacklist groups. Can be external link (http/https) or local file blackLists : ads : - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts - http://sysctl.org/cameleon/hosts - https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt - | # inline definition with YAML literal block scalar style # hosts format someadsdomain.com special : - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts # definition of whitelist groups. Attention: if the same group has black and whitelists, whitelists will be used to disable particular blacklist entries. If a group has only whitelist entries -> this means only domains from this list are allowed, all other domains will be blocked whiteLists : ads : - whitelist.txt - | # inline definition with YAML literal block scalar style # hosts format whitelistdomain.com # this is a regex /^banners?[_.-]/ # definition: which groups should be applied for which client clientGroupsBlock : # default will be used, if no special definition for a client name exists default : - ads - special # use client name (with wildcard support: * - sequence of any characters, [0-9] - range) # or single ip address / client subnet as CIDR notation laptop* : - ads 192.168.178.1/24 : - special # which response will be sent, if query is blocked: # zeroIp: 0.0.0.0 will be returned (default) # nxDomain: return NXDOMAIN as return code # comma separated list of destination IP addresses (for example: 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344). Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page. blockType : zeroIp # optional: TTL for answers to blocked domains # default: 6h blockTTL : 1m # optional: automatically list refresh period (in duration format). Default: 4h. # Negative value -> deactivate automatically refresh. # 0 value -> use default refreshPeriod : 4h # optional: timeout for list download (each url). Default: 60s. Use large values for big lists or slow internet connections downloadTimeout : 4m # optional: Download attempt timeout. Default: 60s downloadAttempts : 5 # optional: Time between the download attempts. Default: 1s downloadCooldown : 10s # optional: if failOnError, application startup will fail if at least one list can't be downloaded / opened. Default: blocking startStrategy : failOnError # optional: configuration for caching of DNS responses caching : # duration how long a response must be cached (min value). # If <=0, use response's TTL, if >0 use this value, if TTL is smaller # Default: 0 minTime : 5m # duration how long a response must be cached (max value). # If <0, do not cache responses # If 0, use TTL # If > 0, use this value, if TTL is greater # Default: 0 maxTime : 30m # Max number of cache entries (responses) to be kept in cache (soft limit). Useful on systems with limited amount of RAM. # Default (0): unlimited maxItemsCount : 0 # if true, will preload DNS results for often used queries (default: names queried more than 5 times in a 2-hour time window) # this improves the response time for often used queries, but significantly increases external traffic # default: false prefetching : true # prefetch track time window (in duration format) # default: 120 prefetchExpires : 2h # name queries threshold for prefetch # default: 5 prefetchThreshold : 5 # Max number of domains to be kept in cache for prefetching (soft limit). Useful on systems with limited amount of RAM. # Default (0): unlimited prefetchMaxItemsCount : 0 # Time how long negative results (NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results. # Default: 30m cacheTimeNegative : 30m # optional: configuration of client name resolution clientLookup : # optional: this DNS resolver will be used to perform reverse DNS lookup (typically local router) upstream : 192.168.178.1 # optional: some routers return multiple names for client (host name and user defined name). Define which single name should be used. # Example: take second name if present, if not take first name singleNameOrder : - 2 - 1 # optional: custom mapping of client name to IP addresses. Useful if reverse DNS does not work properly or just to have custom client names. clients : laptop : - 192.168.178.29 # optional: configuration for prometheus metrics endpoint prometheus : # enabled if true enable : true # url path, optional (default '/metrics') path : /metrics # optional: write query information (question, answer, client, duration etc.) to daily csv file queryLog : # optional one of: mysql, postgresql, csv, csv-client. If empty, log to console type : mysql # directory (should be mounted as volume in docker) for csv, db connection string for mysql/postgresql target : db_user:db_password@tcp(db_host_or_ip:3306)/db_name?charset=utf8mb4&parseTime=True&loc=Local #postgresql target: postgres://user:password@db_host_or_ip:5432/db_name # if > 0, deletes log files which are older than ... days logRetentionDays : 7 # optional: Max attempts to create specific query log writer, default: 3 creationAttempts : 1 # optional: Time between the creation attempts, default: 2s creationCooldown : 2s # optional: Blocky can synchronize its cache and blocking state between multiple instances through redis. redis : # Server address and port address : redis:6379 # Password if necessary password : passwd # Database, default: 0 database : 2 # Connection is required for blocky to start. Default: false required : true # Max connection attempts, default: 3 connectionAttempts : 10 # Time between the connection attempts, default: 1s connectionCooldown : 3s # optional: DNS listener port(s) and bind ip address(es), default 53 (UDP and TCP). Example: 53, :53, \"127.0.0.1:5353,[::1]:5353\" port : 53 # optional: Port(s) and bind ip address(es) for DoT (DNS-over-TLS) listener. Example: 853, 127.0.0.1:853 #tlsPort: 853 # optional: HTTPS listener port(s) and bind ip address(es), default empty = no http listener. If > 0, will be used for prometheus metrics, pprof, REST API, DoH... Example: 443, :443, 127.0.0.1:443 httpPort : 4000 #httpsPort: 443 # optional: Mininal TLS version that the DoH and DoT server will use minTlsServeVersion : 1.3 # if https port > 0: path to cert and key file for SSL encryption. if not set, self-signed certificate will be generated #certFile: server.crt #keyFile: server.key # optional: use this DNS server to resolve blacklist urls and upstream DNS servers. Useful if no DNS resolver is configured and blocky needs to resolve a host name. Format net:IP:port, net must be udp or tcp bootstrapDns : tcp+udp:1.1.1.1 filtering : # optional: drop all queries with following query types. Default: empty queryTypes : - AAAA # optional: if path defined, use this file for query resolution (A, AAAA and rDNS). Default: empty hostsFile : # optional: Path to hosts file (e.g. /etc/hosts on Linux) filePath : /etc/hosts # optional: TTL, default: 1h hostsTTL : 60m # optional: Time between hosts file refresh, default: 1h refreshPeriod : 30m # optional: Whether loopback hosts addresses (127.0.0.0/8 and ::1) should be filtered or not, default: false filterLoopback : true # optional: Log level (one from debug, info, warn, error). Default: info logLevel : info # optional: Log format (text or json). Default: text logFormat : text # optional: log timestamps. Default: true logTimestamp : true # optional: obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. Default: false logPrivacy : false # optional: add EDE error codes to dns response ede : # enabled if true, Default: false enable : true","title":"Configuration"},{"location":"configuration/#basic-configuration","text":"Parameter Type Mandatory Default value Description port [IP]:port[,[IP]:port]* no 53 Port(s) and optional bind ip address(es) to serve DNS endpoint ( TCP and UDP ). If you wish to specify a specific IP, you can do so such as 192.168.0.1:53 . Example: 53 , :53 , 127.0.0.1:53,[::1]:53 tlsPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve DoT DNS endpoint ( DNS -over-TLS). If you wish to specify a specific IP, you can do so such as 192.168.0.1:853 . Example: 83 , :853 , 127.0.0.1:853,[::1]:853 httpPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve HTTP used for prometheus metrics, pprof, REST API , DoH ... If you wish to specify a specific IP, you can do so such as 192.168.0.1:4000 . Example: 4000 , :4000 , 127.0.0.1:4000,[::1]:4000 httpsPort [IP]:port[,[IP]:port]* no Port(s) and optional bind ip address(es) to serve HTTPS used for prometheus metrics, pprof, REST API , DoH ... If you wish to specify a specific IP, you can do so such as 192.168.0.1:443 . Example: 443 , :443 , 127.0.0.1:443,[::1]:443 certFile path no Path to cert and key file for SSL encryption ( DoH and DoT ); if empty, self-signed certificate is generated keyFile path no Path to cert and key file for SSL encryption ( DoH and DoT ); if empty, self-signed certificate is generated logLevel enum (debug, info, warn, error) no info Log level logFormat enum (text, json) no text Log format (text or json). logTimestamp bool no true Log time stamps (true or false). logPrivacy bool no false Obfuscate log output (replace all alphanumeric characters with *) for user sensitive data like request domains or responses to increase privacy. dohUserAgent string no HTTP User Agent for DoH upstreams minTlsServeVersion string no 1.2 Minimum TLS version that the DoT and DoH server use to serve those encrypted DNS requests startVerifyUpstream bool no false If true, blocky will fail to start unless at least one upstream server per group is reachable. connectIPVersion bool no dual IP version to use for outgoing connections (dual, v4, v6) Example port : 53 httpPort : 4000 httpsPort : 443 logLevel : info","title":"Basic configuration"},{"location":"configuration/#upstream-configuration","text":"To resolve a DNS query, blocky needs external public or private DNS resolvers. Blocky supports DNS resolvers with following network protocols (net part of the resolver URL): tcp+udp ( UDP and TCP , dependent on query type) https (aka DoH ) tcp-tls (aka DoT ) Hint You can (and should!) configure multiple DNS resolvers. Blocky picks 2 random resolvers from the list for each query and returns the answer from the fastest one. This improves your network speed and increases your privacy - your DNS traffic will be distributed over multiple providers. Each resolver must be defined as a string in following format: [net:]host:[port][/path][#commonName] . Parameter Type Mandatory Default value net enum (tcp+udp, tcp-tls or https) no tcp+udp host IP or hostname yes port int (1 - 65535) no 53 for udp/tcp, 853 for tcp-tls and 443 for https commonName string no the host value The commonName parameter overrides the expected certificate common name value used for verification. Blocky needs at least the configuration of the default group. This group will be used as a fallback, if no client specific resolver configuration is available. You can use the client name (see Client name lookup ), client's IP address or a client subnet as CIDR notation. Tip You can use * as wildcard for the sequence of any character or [0-9] as number range Example upstream : default : - 5.9.164.112 - 1.1.1.1 - tcp-tls:fdns1.dismail.de:853 - https://dns.digitale-gesellschaft.ch/dns-query laptop* : - 123.123.123.123 10.43.8.67/28 : - 1.1.1.1 - 9.9.9.9 Use 123.123.123.123 as single upstream DNS resolver for client laptop-home, 1.1.1.1 and 9.9.9.9 for all clients in the sub-net 10.43.8.67/28 and 4 resolvers (default) for all others clients. Note Blocky needs at least one upstream DNS server See List of public DNS servers if you need some ideas, which public free DNS server you could use.","title":"Upstream configuration"},{"location":"configuration/#upstream-lookup-timeout","text":"Blocky will wait 2 seconds (default value) for the response from the external upstream DNS server. You can change this value by setting the upstreamTimeout configuration parameter (in duration format ). Example upstream : default : - 46.182.19.48 - 80.241.218.68 upstreamTimeout : 5s","title":"Upstream lookup timeout"},{"location":"configuration/#bootstrap-dns-configuration","text":"This DNS server is used to resolve upstream DoH and DoT servers that are specified as hostnames. Useful if no system DNS resolver is configured, and to encrypt the bootstrap queries. Parameter Type Mandatory Default value Description upstream Upstream (see below) no ips List of IPs yes, if upstream is DoT / DoH Only valid if upstream is DoH or DoT If you only need to specify upstream, you can use the short form: bootstrapDns: <upstream> . Note Works only on Linux/*nix OS due to golang limitations under Windows. Example bootstrapDns : upstream : tcp-tls:dns.example.com ips : - 123.123.123.123","title":"Bootstrap DNS configuration"},{"location":"configuration/#filtering","text":"Under certain circumstances, it may be useful to filter some types of DNS queries. You can define one or more DNS query types, all queries with these types will be dropped (empty answer will be returned). Example filtering : queryTypes : - AAAA This configuration will drop all 'AAAA' (IPv6) queries.","title":"Filtering"},{"location":"configuration/#fqdn-only","text":"In domain environments, it may be usefull to only response to FQDN requests. If this option is enabled blocky respond immidiatly with NXDOMAIN if the request is not a valid FQDN. The request is therfore not further processed by other options like custom or conditional. Please be aware that by enabling it your hostname resolution will break unless every hostname is part of a domain. Example fqdnOnly : true","title":"FQDN only"},{"location":"configuration/#custom-dns","text":"You can define your own domain name to IP mappings. For example, you can use a user-friendly name for a network printer or define a domain name for your local device on order to use the HTTPS certificate. Multiple IP addresses for one domain must be separated by a comma. Parameter Type Mandatory Default value customTTL duration (no unit is minutes) no 1h rewrite string: string (domain: domain) no mapping string: string (hostname: address list) no filterUnmappedTypes boolean no true Example customDNS : customTTL : 1h filterUnmappedTypes : true rewrite : home : lan replace-me.com : with-this.com mapping : printer.lan : 192.168.178.3 otherdevice.lan : 192.168.178.15,2001:0db8:85a3:08d3:1319:8a2e:0370:7344 This configuration will also resolve any subdomain of the defined domain. For example a query \"printer.lan\" or \" my.printer.lan\" will return 192.168.178.3 as IP address. With the optional parameter rewrite you can replace domain part of the query with the defined part before the resolver lookup is performed. The query \"printer.home\" will be rewritten to \"printer.lan\" and return 192.168.178.3. With parameter filterUnmappedTypes = true (default), blocky will filter all queries with unmapped types, for example: AAAA for \"printer.lan\" or TXT for \"otherdevice.lan\". With filterUnmappedTypes = false a query AAAA \"printer.lan\" will be forwarded to the upstream DNS server.","title":"Custom DNS"},{"location":"configuration/#conditional-dns-resolution","text":"You can define, which DNS resolver(s) should be used for queries for the particular domain (with all subdomains). This is for example useful, if you want to reach devices in your local network by the name. Since only your router know which hostname belongs to which IP address, all DNS queries for the local network should be redirected to the router. The optional parameter rewrite behaves the same as with custom DNS . The optional parameter fallbackUpstream, if false (default), return empty result if after rewrite, the mapped resolver returned an empty answer. If true, the original query will be sent to the upstream resolver.","title":"Conditional DNS resolution"},{"location":"configuration/#usage-one-usecase-when-having-split-dns-for-internal-and-external-internet-facing-users-but-not-all-subdomains-are-listed-in-the-internal-domain","text":"Example conditional : fallbackUpstream : false rewrite : example.com : fritz.box replace-me.com : with-this.com mapping : fritz.box : 192.168.178.1 lan.net : 192.170.1.2,192.170.1.3 # for reverse DNS lookups of local devices 178.168.192.in-addr.arpa : 192.168.178.1 # for all unqualified hostnames . : 168.168.0.1 Tip You can use . as wildcard for all non full qualified domains (domains without dot) In this example, a DNS query \"client.fritz.box\" will be redirected to the router's DNS server at 192.168.178.1 and client.lan.net to 192.170.1.2 and 192.170.1.3. The query \"client.example.com\" will be rewritten to \"client.fritz.box\" and also redirected to the resolver at 192.168.178.1. If not found and if fallbackUpstream was set to true , the original query \"blog.example.com\" will be sent upstream. All unqualified hostnames (e.g. \"test\") will be redirected to the DNS server at 168.168.0.1. One usecase for fallbackUpstream is when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain.","title":"Usage: One usecase when having split DNS for internal and external (internet facing) users, but not all subdomains are listed in the internal domain"},{"location":"configuration/#client-name-lookup","text":"Blocky can try to resolve a user-friendly client name from the IP address or server URL ( DoT and DoH ). This is useful for defining of blocking groups, since IP address can change dynamically.","title":"Client name lookup"},{"location":"configuration/#resolving-client-name-from-urlhost","text":"If DoT or DoH is enabled, you can use a subdomain prefixed with id- to provide a client name (wildcard ssl certificate recommended). Example: domain example.com DoT Host: id-bob.example.com -> request's client name is bob DoH URL: https://id-bob.example.com/dns-query -> request's client name is bob For DoH you can also pass the client name as url parameter: DoH URL: https://blocky.example.com/dns-query/alice -> request's client name is alice","title":"Resolving client name from URL/Host"},{"location":"configuration/#resolving-client-name-from-ip-address","text":"Blocky uses rDNS to retrieve client's name. To use this feature, you can configure a DNS server for client lookup ( typically your router). You can also define client names manually per IP address.","title":"Resolving client name from IP address"},{"location":"configuration/#single-name-order","text":"Some routers return multiple names for the client (host name and user defined name). With parameter clientLookup.singleNameOrder you can specify, which of retrieved names should be used.","title":"Single name order"},{"location":"configuration/#custom-client-name-mapping","text":"You can also map a particular client name to one (or more) IP (ipv4/ipv6) addresses. Parameter clientLookup.clients contains a map of client name and multiple IP addresses. Example clientLookup : upstream : 192.168.178.1 singleNameOrder : - 2 - 1 clients : laptop : - 192.168.178.29 Use 192.168.178.1 for rDNS lookup. Take second name if present, if not take first name. IP address 192.168.178.29 is mapped to laptop as client name.","title":"Custom client name mapping"},{"location":"configuration/#blocking-and-whitelisting","text":"Blocky can download and use external lists with domains or IP addresses to block DNS query (e.g. advertisement, malware, trackers, adult sites). You can group several list sources together and define the blocking behavior per client. External blacklists must be either in the well-known Hosts format or just a plain domain list (one domain per line). Blocky also supports regex as more powerful tool to define patterns to block. Blocky uses DNS sinkhole approach to block a DNS query. Domain name from the request, IP address from the response, and the CNAME record will be checked against configured blacklists. To avoid over-blocking, you can define or use already existing whitelists.","title":"Blocking and whitelisting"},{"location":"configuration/#definition-black-and-whitelists","text":"Each black or whitelist can be either a path to the local file, a URL to download or inline list definition of a domains in hosts format ( YAML literal block scalar style). All Urls must be grouped to a group name. Example blocking : blackLists : ads : - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts - | # inline definition with YAML literal block scalar style someadsdomain.com anotheradsdomain.com # this is a regex /^banners?[_.-]/ special : - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts whiteLists : ads : - whitelist.txt - | # inline definition with YAML literal block scalar style whitelistdomain.com In this example you can see 2 groups: ads with 2 lists and special with one list. One local whitelist was defined for the ads group. Warning If the same group has black and whitelists, whitelists will be used to disable particular blacklist entries. If a group has only whitelist entries -> this means only domains from this list are allowed, all other domains will be blocked Note Please define also client group mapping, otherwise you black and whitelist definition will have no effect","title":"Definition black and whitelists"},{"location":"configuration/#regex-support","text":"You can use regex to define patterns to block. A regex entry must start and end with the slash character (/). Some Examples: /baddomain/ will block www.baddomain.com , baddomain.com , but also mybaddomain-sometext.com /^baddomain/ will block baddomain.com , but not www.baddomain.com /^apple\\.(de|com)$/ will only block apple.de and apple.com","title":"Regex support"},{"location":"configuration/#client-groups","text":"In this configuration section, you can define, which blocking group(s) should be used for which client in your network. Example: All clients should use the ads group, which blocks advertisement and kids devices should use the adult group, which blocky adult sites. Clients without a group assignment will use automatically the default group. You can use the client name (see Client name lookup ), client's IP address, client's full-qualified domain name or a client subnet as CIDR notation. If full-qualified domain name is used (for example \"myclient.ddns.org\"), blocky will try to resolve the IP address (A and AAAA records) of this domain. If client's IP address matches with the result, the defined group will be used. Example blocking : clientGroupsBlock : # default will be used, if no special definition for a client name exists default : - ads - special laptop* : - ads 192.168.178.1/24 : - special kid-laptop : - ads - adult All queries from network clients, whose device name starts with laptop , will be filtered against the ads group's lists. All devices from the subnet 192.168.178.1/24 against the special group and kid-laptop against ads and adult . All other clients: ads and special . Tip You can use * as wildcard for the sequence of any character or [0-9] as number range","title":"Client groups"},{"location":"configuration/#block-type","text":"You can configure, which response should be sent to the client, if a requested query is blocked (only for A and AAAA queries, NXDOMAIN for other types): blockType Example Description zeroIP zeroIP This is the default block type. Server returns 0.0.0.0 (or :: for IPv6) as result for A and AAAA queries nxDomain nxDomain return NXDOMAIN as return code custom IPs 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 comma separated list of destination IP addresses. Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the \"blocked\" page. Example blocking : blockType : nxDomain","title":"Block type"},{"location":"configuration/#block-ttl","text":"TTL for answers to blocked domains can be set to customize the time (in duration format ) clients ask for those domains again. Default Block TTL is 6hours . This setting only makes sense when blockType is set to nxDomain or zeroIP , and will affect how much time it could take for a client to be able to see the real IP address for a domain after receiving the custom value. Example blocking : blockType : 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344 blockTTL : 10s","title":"Block TTL"},{"location":"configuration/#list-refresh-period","text":"To keep the list cache up-to-date, blocky will periodically download and reload all external lists. Default period is 4 hours . You can configure this by setting the blocking.refreshPeriod parameter to a value in duration format . Negative value will deactivate automatically refresh. Example blocking : refreshPeriod : 60m Refresh every hour.","title":"List refresh period"},{"location":"configuration/#download","text":"You can configure the list download attempts according to your internet connection: Parameter Type Mandatory Default value Description downloadTimeout duration format no 60s Download attempt timeout downloadAttempts int no 3 How many download attempts should be performed downloadCooldown duration format no 1s Time between the download attempts Example blocking : downloadTimeout : 4m downloadAttempts : 5 downloadCooldown : 10s","title":"Download"},{"location":"configuration/#start-strategy","text":"You can configure the blocking behavior during application start of blocky. If no starategy is selected blocking will be used. startStrategy Description blocking all blocking lists will be loaded before DNS resoulution starts failOnError like blocking but blocky shutsdown if an download fails fast DNS resolution starts immediately without blocking which will be enabled after list load is completed Example blocking : startStrategy : failOnError","title":"Start strategy"},{"location":"configuration/#concurrency","text":"Blocky downloads and processes links in a single group concurrently. With parameter processingConcurrency you can adjust how many links can be processed in the same time. Higher value can reduce the overall list refresh time, but more parallel download and processing jobs need more RAM. Please consider to reduce this value on systems with limited memory. Default value is 4. Example blocking : processingConcurrency : 10","title":"Concurrency"},{"location":"configuration/#caching","text":"Each DNS response has a TTL (Time-to-live) value. This value defines, how long is the record valid in seconds. The values are maintained by domain owners, server administrators etc. Blocky caches the answers from all resolved queries in own cache in order to avoid repeated requests. This reduces the DNS traffic and increases the network speed, since blocky can serve the result immediately from the cache. With following parameters you can tune the caching behavior: Warning Wrong values can significantly increase external DNS traffic or memory consumption. Parameter Type Mandatory Default value Description caching.minTime duration format no 0 (use TTL ) How long a response must be cached (min value). If <=0, use response's TTL , if >0 use this value, if TTL is smaller caching.maxTime duration format no 0 (use TTL ) How long a response must be cached (max value). If <0, do not cache responses. If 0, use TTL . If > 0, use this value, if TTL is greater caching.maxItemsCount int no 0 (unlimited) Max number of cache entries (responses) to be kept in cache (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.prefetching bool no false if true, blocky will preload DNS results for often used queries (default: names queried more than 5 times in a 2 hour time window). Results in cache will be loaded again on their expire ( TTL ). This improves the response time for often used queries, but significantly increases external traffic. It is recommended to increase \"minTime\" to reduce the number of prefetch queries to external resolvers. caching.prefetchExpires duration format no 2h Prefetch track time window caching.prefetchThreshold int no 5 Name queries threshold for prefetch caching.prefetchMaxItemsCount int no 0 (unlimited) Max number of domains to be kept in cache for prefetching (soft limit). Default (0): unlimited. Useful on systems with limited amount of RAM. caching.cacheTimeNegative duration format no 30m Time how long negative results ( NXDOMAIN response or empty result) are cached. A value of -1 will disable caching for negative results. Example caching : minTime : 5m maxTime : 30m prefetching : true","title":"Caching"},{"location":"configuration/#redis","text":"Blocky can synchronize its cache and blocking state between multiple instances through redis. Synchronization is disabled if no address is configured. Parameter Type Mandatory Default value Description redis.address string no Server address and port redis.password string no Password if necessary redis.database int no 0 Database redis.required bool no false Connection is required for blocky to start redis.connectionAttempts int no 3 Max connection attempts redis.connectionCooldown duration format no 1s Time between the connection attempts Example redis : address : redis:6379 password : passwd database : 2 required : true connectionAttempts : 10 connectionCooldown : 3s","title":"Redis"},{"location":"configuration/#prometheus","text":"Blocky can expose various metrics for prometheus. To use the prometheus feature, the HTTP listener must be enabled ( see Basic Configuration ). Parameter Mandatory Default value Description prometheus.enable no false If true, enables prometheus metrics prometheus.path no /metrics URL path to the metrics endpoint Example prometheus : enable : true path : /metrics","title":"Prometheus"},{"location":"configuration/#query-logging","text":"You can enable the logging of DNS queries (question, answer, client, duration etc.) to a daily CSV file (can be opened in Excel or OpenOffice Calc) or MySQL/MariaDB database. Warning Query file/database contains sensitive information. Please ensure to inform users, if you log their queries.","title":"Query logging"},{"location":"configuration/#query-log-types","text":"You can select one of following query log types: mysql - log each query in the external MySQL/MariaDB database postgresql - log each query in the external PostgreSQL database csv - log into CSV file (one per day) csv-client - log into CSV file (one per day and per client) console - log into console output none - do not log any queries Configuration parameters: Parameter Type Mandatory Default value Description queryLog.type enum (mysql, postgresql, csv, csv-client, console, none (see above)) no Type of logging target. Console if empty queryLog.target string no directory for writing the logs (for csv) or database url (for mysql or postgresql) queryLog.logRetentionDays int no 0 if > 0, deletes log files/database entries which are older than ... days queryLog.creationAttempts int no 3 Max attempts to create specific query log writer queryLog.CreationCooldown duration format no 2 Time between the creation attempts Hint Please ensure, that the log directory is writable or database exists. If you use docker, please ensure, that the directory is properly mounted (e.g. volume) example for CSV format Example queryLog : type : csv target : /logs logRetentionDays : 7 example for Database Example queryLog : type : mysql target : db_user:db_password@tcp(db_host_or_ip:3306)/db_user?charset=utf8mb4&parseTime=True&loc=Local logRetentionDays : 7","title":"Query log types"},{"location":"configuration/#hosts-file","text":"You can enable resolving of entries, located in local hosts file. Configuration parameters: Parameter Type Mandatory Default value Description hostsFile.filePath string no Path to hosts file (e.g. /etc/hosts on Linux) hostsFile.hostsTTL duration (no units is minutes) no 1h TTL hostsFile.refreshPeriod duration format no 1h Time between hosts file refresh hostsFile.filterLoopback bool no false Filter loopback addresses (127.0.0.0/8 and ::1) Example hostsFile : filePath : /etc/hosts hostsTTL : 60m refreshPeriod : 30m","title":"Hosts file"},{"location":"configuration/#deliver-ede-codes-as-edns0-option","text":"DNS responses can be extended with EDE codes according to RFC8914 . Configuration parameters: Parameter Type Mandatory Default value Description ede.enable bool no false If true, DNS responses are deliverd with EDE codes Example ede : enable : true","title":"Deliver EDE codes as EDNS0 option"},{"location":"configuration/#ssl-certificate-configuration-doh-tls-listener","text":"See Wiki - Configuration of HTTPS for detailed information, how to create and configure SSL certificates. DoH url: https://host:port/dns-query","title":"SSL certificate configuration (DoH / TLS listener)"},{"location":"installation/","text":"Installation You can choose one of the following installation options: Run as standalone binary Run as docker container Kubernetes with helm chart Prepare your configuration Blocky supports single or multiple YAML files as configuration. Create new config.yaml with your configuration ( see Configuration for more details and all configuration options). Simple configuration file, which enables only basic features: upstream : default : - 46.182.19.48 - 80.241.218.68 - tcp-tls:fdns1.dismail.de:853 - https://dns.digitale-gesellschaft.ch/dns-query blocking : blackLists : ads : - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts clientGroupsBlock : default : - ads port : 53 httpPort : 4000 Run as standalone binary Download the binary file from GitHub for your architecture and run ./blocky --config config.yml . Warning Please be aware, if you want to use port 53 or 953 on Linux you should add CAP_NET_BIND_SERVICE capability to the binary or run with root privileges (running as root is not recommended). Run with docker Alternative registry Blocky docker images are deployed to DockerHub ( spx01/blocky ) and GitHub Container Registry ( ghcr.io/0xerr0r/blocky ) . Parameters You can define the location of the config file in the container with environment variable \"CONFIG_FILE\". Default value is \"/app/config.yml\". Docker from command line Execute following command from the command line: docker run --name blocky -v /path/to/config.yml:/app/config.yml -p 4000:4000 -p 53:53/udp spx01/blocky Run with docker-compose Create following docker-compose.yml file version : \"2.1\" services : blocky : image : spx01/blocky container_name : blocky restart : unless-stopped ports : - \"53:53/tcp\" - \"53:53/udp\" - \"4000:4000/tcp\" environment : - TZ=Europe/Berlin # Optional to synchronize the log timestamp with host volumes : # config file - ./config.yml:/app/config.yml and start docker container with docker-compose up -d Advanced setup Following example shows, how to run blocky in a docker container and store query logs on a SAMBA share. Local black and whitelists directories are mounted as volume. You can create own black or whitelists in these directories and define the path like '/app/whitelists/whitelist.txt' in the config file. Example version : \"2.1\" services : blocky : image : spx01/blocky container_name : blocky restart : unless-stopped ports : - \"53:53/tcp\" - \"53:53/udp\" - \"4000:4000/tcp\" # Prometheus stats (if enabled). environment : - TZ=Europe/Berlin volumes : # config file - ./config.yml:/app/config.yml # write query logs in this volume - queryLogs:/logs # put your custom white and blacklists in these directories - ./blacklists:/app/blacklists/ - ./whitelists:/app/whitelists/ volumes : queryLogs : driver : local driver_opts : type : cifs o : username=USER,password=PASSWORD,rw device : //NAS_HOSTNAME/blocky Multiple configuration files For complex setups, splitting the configuration between multiple YAML files might be desired. In this case, folder containing YAML files is passed on startup, Blocky will join all the files. ./blocky --config ./config/ Warning Blocky simply joins the multiple YAML files. If a directive (e.g. upstream ) is repeated in multiple files, the configuration will not load and start will fail. Other installation types Warning These projects are maintained by other people. Web UI Blocky Frontend provides a Web UI to control blocky. See linked project for installation instructions. Run with helm chart on Kubernetes See this repo , the documentation and the configuration instructions for details about running blocky via helm in kubernetes. Run as an App for TrueNAS SCALE You can find the App in the TrueCharts App Catalog or read the documentation and configuration instructions for details about running blocky as a native TrueNAS SCALE App. AUR package for Arch Linux See https://aur.archlinux.org/packages/blocky/ Package for Alpine Linux See https://pkgs.alpinelinux.org/package/edge/testing/x86/blocky Installation script for CentOS/Fedora See https://github.com/m0zgen/blocky-installer Package for FreeBSD See https://www.freebsd.org/cgi/ports.cgi?query=blocky&stype=all","title":"Installation"},{"location":"installation/#installation","text":"You can choose one of the following installation options: Run as standalone binary Run as docker container Kubernetes with helm chart","title":"Installation"},{"location":"installation/#prepare-your-configuration","text":"Blocky supports single or multiple YAML files as configuration. Create new config.yaml with your configuration ( see Configuration for more details and all configuration options). Simple configuration file, which enables only basic features: upstream : default : - 46.182.19.48 - 80.241.218.68 - tcp-tls:fdns1.dismail.de:853 - https://dns.digitale-gesellschaft.ch/dns-query blocking : blackLists : ads : - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts clientGroupsBlock : default : - ads port : 53 httpPort : 4000","title":"Prepare your configuration"},{"location":"installation/#run-as-standalone-binary","text":"Download the binary file from GitHub for your architecture and run ./blocky --config config.yml . Warning Please be aware, if you want to use port 53 or 953 on Linux you should add CAP_NET_BIND_SERVICE capability to the binary or run with root privileges (running as root is not recommended).","title":"Run as standalone binary"},{"location":"installation/#run-with-docker","text":"","title":"Run with docker"},{"location":"installation/#alternative-registry","text":"Blocky docker images are deployed to DockerHub ( spx01/blocky ) and GitHub Container Registry ( ghcr.io/0xerr0r/blocky ) .","title":"Alternative registry"},{"location":"installation/#parameters","text":"You can define the location of the config file in the container with environment variable \"CONFIG_FILE\". Default value is \"/app/config.yml\".","title":"Parameters"},{"location":"installation/#docker-from-command-line","text":"Execute following command from the command line: docker run --name blocky -v /path/to/config.yml:/app/config.yml -p 4000:4000 -p 53:53/udp spx01/blocky","title":"Docker from command line"},{"location":"installation/#run-with-docker-compose","text":"Create following docker-compose.yml file version : \"2.1\" services : blocky : image : spx01/blocky container_name : blocky restart : unless-stopped ports : - \"53:53/tcp\" - \"53:53/udp\" - \"4000:4000/tcp\" environment : - TZ=Europe/Berlin # Optional to synchronize the log timestamp with host volumes : # config file - ./config.yml:/app/config.yml and start docker container with docker-compose up -d","title":"Run with docker-compose"},{"location":"installation/#advanced-setup","text":"Following example shows, how to run blocky in a docker container and store query logs on a SAMBA share. Local black and whitelists directories are mounted as volume. You can create own black or whitelists in these directories and define the path like '/app/whitelists/whitelist.txt' in the config file. Example version : \"2.1\" services : blocky : image : spx01/blocky container_name : blocky restart : unless-stopped ports : - \"53:53/tcp\" - \"53:53/udp\" - \"4000:4000/tcp\" # Prometheus stats (if enabled). environment : - TZ=Europe/Berlin volumes : # config file - ./config.yml:/app/config.yml # write query logs in this volume - queryLogs:/logs # put your custom white and blacklists in these directories - ./blacklists:/app/blacklists/ - ./whitelists:/app/whitelists/ volumes : queryLogs : driver : local driver_opts : type : cifs o : username=USER,password=PASSWORD,rw device : //NAS_HOSTNAME/blocky","title":"Advanced setup"},{"location":"installation/#multiple-configuration-files","text":"For complex setups, splitting the configuration between multiple YAML files might be desired. In this case, folder containing YAML files is passed on startup, Blocky will join all the files. ./blocky --config ./config/ Warning Blocky simply joins the multiple YAML files. If a directive (e.g. upstream ) is repeated in multiple files, the configuration will not load and start will fail.","title":"Multiple configuration files"},{"location":"installation/#other-installation-types","text":"Warning These projects are maintained by other people.","title":"Other installation types"},{"location":"installation/#web-ui","text":"Blocky Frontend provides a Web UI to control blocky. See linked project for installation instructions.","title":"Web UI"},{"location":"installation/#run-with-helm-chart-on-kubernetes","text":"See this repo , the documentation and the configuration instructions for details about running blocky via helm in kubernetes.","title":"Run with helm chart on Kubernetes"},{"location":"installation/#run-as-an-app-for-truenas-scale","text":"You can find the App in the TrueCharts App Catalog or read the documentation and configuration instructions for details about running blocky as a native TrueNAS SCALE App.","title":"Run as an App for TrueNAS SCALE"},{"location":"installation/#aur-package-for-arch-linux","text":"See https://aur.archlinux.org/packages/blocky/","title":"AUR package for Arch Linux"},{"location":"installation/#package-for-alpine-linux","text":"See https://pkgs.alpinelinux.org/package/edge/testing/x86/blocky","title":"Package for Alpine Linux"},{"location":"installation/#installation-script-for-centosfedora","text":"See https://github.com/m0zgen/blocky-installer","title":"Installation script for CentOS/Fedora"},{"location":"installation/#package-for-freebsd","text":"See https://www.freebsd.org/cgi/ports.cgi?query=blocky&stype=all","title":"Package for FreeBSD"},{"location":"interfaces/","text":"Interfaces REST API If http listener is enabled, blocky provides REST API . You can browse the API documentation (Swagger) documentation under https://0xERR0R.github.io/blocky/swagger.html . CLI Blocky provides a CLI interface to control. This interface uses internally the REST API . To run the CLI , please ensure, that blocky DNS server is running, then execute blocky help for help or ./blocky blocking enable to enable blocking ./blocky blocking disable to disable blocking ./blocky blocking disable --duration [duration] to disable blocking for a certain amount of time (30s, 5m, 10m30s, ...) ./blocky blocking disable --groups ads,othergroup to disable blocking only for special groups ./blocky blocking status to print current status of blocking ./blocky query <domain> execute DNS query (A) (simple replacement for dig, useful for debug purposes) ./blocky query <domain> --type <queryType> execute DNS query with passed query type (A, AAAA, MX, ...) ./blocky lists refresh reloads all white and blacklists Tip To run this inside docker run docker exec blocky ./blocky blocking status","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"","title":"Interfaces"},{"location":"interfaces/#rest-api","text":"If http listener is enabled, blocky provides REST API . You can browse the API documentation (Swagger) documentation under https://0xERR0R.github.io/blocky/swagger.html .","title":"REST API"},{"location":"interfaces/#cli","text":"Blocky provides a CLI interface to control. This interface uses internally the REST API . To run the CLI , please ensure, that blocky DNS server is running, then execute blocky help for help or ./blocky blocking enable to enable blocking ./blocky blocking disable to disable blocking ./blocky blocking disable --duration [duration] to disable blocking for a certain amount of time (30s, 5m, 10m30s, ...) ./blocky blocking disable --groups ads,othergroup to disable blocking only for special groups ./blocky blocking status to print current status of blocking ./blocky query <domain> execute DNS query (A) (simple replacement for dig, useful for debug purposes) ./blocky query <domain> --type <queryType> execute DNS query with passed query type (A, AAAA, MX, ...) ./blocky lists refresh reloads all white and blacklists Tip To run this inside docker run docker exec blocky ./blocky blocking status","title":"CLI"},{"location":"network_configuration/","text":"Network configuration In order, to benefit from all the advantages of blocky like ad-blocking, privacy and speed, it is necessary to use blocky as DNS server for your devices. You can configure DNS server on each device manually or use DHCP in your network router and push the right settings to your device. With this approach, you will configure blocky only once in your router and each device in your network will automatically use blocky as DNS server. Transparent configuration with DHCP Let us assume, blocky is installed on a Raspberry PI with fix IP address 192.168.178.2 . Each device which connects to the router will obtain an IP address and receive the network configuration. The IP address of the Raspberry PI should be pushed to the device as DNS server. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Raspberry PI \u2502 \u2502 Router \u2502 \u2502 blocky \u2502 \u2502 \u2502 \u2502 192.168.178.2 \u2502 \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25021 \u2502 \u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 2 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Network device \u2502 \u2502 \u2502 Android \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 1 - Network device asks the DHCP server (on Router) for the network configuration 2 - Router assigns a free IP address to the device and says \"Use 192.168.178.2\" as DNS server 3 - Clients makes DNS queries and is happy to use blocky Warning It is necessary to assign the server which runs blocky (e.g. Raspberry PI) a fix IP address. Example configuration with FritzBox To configure the DNS server in the FritzBox, please open in the FritzBox web interface: in navigation menu on the left side: Home Network -> Network Network Settings tab on the top \"IPv4 Configuration\" Button at the bottom op the page Enter the IP address of blocky under \"Local DNS server\", see screenshot","title":"Network configuration"},{"location":"network_configuration/#network-configuration","text":"In order, to benefit from all the advantages of blocky like ad-blocking, privacy and speed, it is necessary to use blocky as DNS server for your devices. You can configure DNS server on each device manually or use DHCP in your network router and push the right settings to your device. With this approach, you will configure blocky only once in your router and each device in your network will automatically use blocky as DNS server.","title":"Network configuration"},{"location":"network_configuration/#transparent-configuration-with-dhcp","text":"Let us assume, blocky is installed on a Raspberry PI with fix IP address 192.168.178.2 . Each device which connects to the router will obtain an IP address and receive the network configuration. The IP address of the Raspberry PI should be pushed to the device as DNS server. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Raspberry PI \u2502 \u2502 Router \u2502 \u2502 blocky \u2502 \u2502 \u2502 \u2502 192.168.178.2 \u2502 \u2514\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25021 \u2502 \u2502 3 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 2 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Network device \u2502 \u2502 \u2502 Android \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 1 - Network device asks the DHCP server (on Router) for the network configuration 2 - Router assigns a free IP address to the device and says \"Use 192.168.178.2\" as DNS server 3 - Clients makes DNS queries and is happy to use blocky Warning It is necessary to assign the server which runs blocky (e.g. Raspberry PI) a fix IP address.","title":"Transparent configuration with DHCP"},{"location":"network_configuration/#example-configuration-with-fritzbox","text":"To configure the DNS server in the FritzBox, please open in the FritzBox web interface: in navigation menu on the left side: Home Network -> Network Network Settings tab on the top \"IPv4 Configuration\" Button at the bottom op the page Enter the IP address of blocky under \"Local DNS server\", see screenshot","title":"Example configuration with FritzBox"},{"location":"prometheus_grafana/","text":"Integration in Grafana Prometheus Prometheus export Blocky can optionally export metrics for Prometheus . Following metrics will be exported: name Description blocky_blacklist_cache / blocky_whitelist_cache Number of entries in blacklist/whitelist cache, partitioned by group blocky_error_total Counter for internal errors blocky_query_total Number of total queries, partitioned by client and DNS request type (A, AAAA, PTR, etc) blocky_request_duration_ms_bucket Request duration histogram, partitioned by response type (Blocked, cached, etc) blocky_response_total Number of responses, partitioned by response type (Blocked, cached, etc), DNS response code, and reason blocky_blocking_enabled 1 if blocking is enabled, 0 otherwise blocky_cache_entry_count Number of entries in cache blocky_cache_hit_count / blocky_cache_miss_count Cache hit/miss counters blocky_prefetch_count Amount of prefetched DNS responses blocky_prefetch_domain_name_cache_count Amount of domain names being prefetched blocky_failed_download_count Number of failed list downloads Grafana dashboard Example Grafana dashboard definition as JSON or at grafana.com . This dashboard shows all relevant statistics and allows enabling and disabling the blocking status. Grafana configuration Please install grafana-piechart-panel and set disable-sanitize-html in config or as env to use control buttons to enable/disable the blocking status. Grafana and Prometheus example project This repo contains example docker-compose.yml with blocky, prometheus (with configured scraper for blocky) and grafana with prometheus datasource. MySQL / MariaDB If database query logging is activated (see Query logging ), you can use following Grafana Dashboard as JSON or at grafana.com . Please define the MySQL source in Grafana, which points to the database with blocky's log entries. Postgres The JSON for a Grafana dashboard equivalent to the MySQL/MariaDB version is located here","title":"Prometheus / Grafana"},{"location":"prometheus_grafana/#integration-in-grafana","text":"","title":"Integration in Grafana"},{"location":"prometheus_grafana/#prometheus","text":"","title":"Prometheus"},{"location":"prometheus_grafana/#prometheus-export","text":"Blocky can optionally export metrics for Prometheus . Following metrics will be exported: name Description blocky_blacklist_cache / blocky_whitelist_cache Number of entries in blacklist/whitelist cache, partitioned by group blocky_error_total Counter for internal errors blocky_query_total Number of total queries, partitioned by client and DNS request type (A, AAAA, PTR, etc) blocky_request_duration_ms_bucket Request duration histogram, partitioned by response type (Blocked, cached, etc) blocky_response_total Number of responses, partitioned by response type (Blocked, cached, etc), DNS response code, and reason blocky_blocking_enabled 1 if blocking is enabled, 0 otherwise blocky_cache_entry_count Number of entries in cache blocky_cache_hit_count / blocky_cache_miss_count Cache hit/miss counters blocky_prefetch_count Amount of prefetched DNS responses blocky_prefetch_domain_name_cache_count Amount of domain names being prefetched blocky_failed_download_count Number of failed list downloads","title":"Prometheus export"},{"location":"prometheus_grafana/#grafana-dashboard","text":"Example Grafana dashboard definition as JSON or at grafana.com . This dashboard shows all relevant statistics and allows enabling and disabling the blocking status.","title":"Grafana dashboard"},{"location":"prometheus_grafana/#grafana-configuration","text":"Please install grafana-piechart-panel and set disable-sanitize-html in config or as env to use control buttons to enable/disable the blocking status.","title":"Grafana configuration"},{"location":"prometheus_grafana/#grafana-and-prometheus-example-project","text":"This repo contains example docker-compose.yml with blocky, prometheus (with configured scraper for blocky) and grafana with prometheus datasource.","title":"Grafana and Prometheus example project"},{"location":"prometheus_grafana/#mysql-mariadb","text":"If database query logging is activated (see Query logging ), you can use following Grafana Dashboard as JSON or at grafana.com . Please define the MySQL source in Grafana, which points to the database with blocky's log entries.","title":"MySQL / MariaDB"},{"location":"prometheus_grafana/#postgres","text":"The JSON for a Grafana dashboard equivalent to the MySQL/MariaDB version is located here","title":"Postgres"},{"location":"includes/abbreviations/","text":"","title":"Abbreviations"}]}